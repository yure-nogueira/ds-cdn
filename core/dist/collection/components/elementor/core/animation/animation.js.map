{"version":3,"file":"animation.js","sourceRoot":"","sources":["../../../../../src/components/elementor/core/animation/animation.tsx"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,EAAE,MAAM,eAAe,CAAC;AACzE,+EAA+E;AAO/E,MAAM,OAAO,WAAW;;QAwEtB,oDAAoD;QACpD,cAAS,GAAG,CAAC,CAAC;QACd,kBAAa,GAAG,CAAC,CAAC;6BAtEuB,KAAK;;yBAW5C,QAAQ;qBAK+B,CAAC;sBAKxB,KAAK;;IAiBvB,iBAAiB;QACf,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;QACxD,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAE7B,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;YACvB,OAAO,CAAC,GAAG,CAAC,iCAAiC,CAAC,CAAC;YAC/C,IAAI,CAAC,aAAa,EAAE,CAAC;QACvB,CAAC;aAAM,CAAC;YACN,yFAAyF;YACzF,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAC3B,CAAC;IACH,CAAC;IAED,oBAAoB;QAClB,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,CAAC;IAC7B,CAAC;IAED,aAAa;QACX,IAAI,CAAC,QAAQ,GAAG,IAAI,oBAAoB,CACtC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,EACnC;YACE,IAAI,EAAE,IAAI,CAAC,UAAU;YACrB,UAAU,EAAE,eAAe;YAC3B,SAAS,EAAE,CAAC;SACb,CACF,CAAC;QAEF,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACnC,CAAC;IAMD,mBAAmB,CAAC,OAAoC;QACtD,mCAAmC;QACnC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,cAAc,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;YAC9C,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACzB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACrB,CAAC;QACD,+BAA+B;QAC/B,wBAAwB;QACxB,6BAA6B;QAE7B,iDAAiD;QACjD,kDAAkD;QAClD,iDAAiD;QAEjD,yBAAyB;QACzB,qCAAqC;QACrC,iEAAiE;QACjE,6CAA6C;QAC7C,kCAAkC;QAClC,eAAe;QACf,6CAA6C;QAC7C,QAAQ;QACR,8DAA8D;QAC9D,+CAA+C;QAC/C,2CAA2C;QAC3C,eAAe;QACf,2CAA2C;QAC3C,QAAQ;QACR,MAAM;QAEN,+BAA+B;QAC/B,uCAAuC;QACvC,MAAM;IACR,CAAC;IAED,iBAAiB;QACf,4BAA4B;QAC5B,mBAAmB;QACnB,gCAAgC;QAChC,aAAa;QACb,oBAAoB;QACpB,6CAA6C;QAC7C,aAAa;QACb,2BAA2B;QAC3B,kEAAkE;QAClE,yEAAyE;QACzE,aAAa;QACb,IAAI;IACN,CAAC;IAED,MAAM;QACJ,MAAM,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC;QAE3B,OAAO,CACL,EAAC,IAAI,qDACH,KAAK,EAAE;gBACL,cAAc,EAAE,IAAI;gBACpB,CAAC,iBAAiB,SAAS,EAAE,CAAC,EAAE,IAAI;aACrC;YAED,8DAAQ,CACH,CACR,CAAC;IACJ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CACF","sourcesContent":["import { Component, Element, Host, Prop, State, h } from '@stencil/core';\r\n// import { fadein, slideup, slideupStagger } from './utils/animations.helper';\r\n\r\n@Component({\r\n  tag: 'tp-animation',\r\n  styleUrl: 'animation.scss',\r\n  scoped: true,\r\n})\r\nexport class TpAnimation {\r\n  /**\r\n   * todo.\r\n   */\r\n  @Prop({ reflect: true }) scrollTrigger = false;\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  @Prop({ reflect: true }) selector: string;\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  @Prop({ reflect: true }) animation: 'fadein' | 'slideup' | 'slideupStagger' =\r\n    'fadein';\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  @Prop({ reflect: true }) delay: number = 0;\r\n\r\n  /**\r\n   * Define se a animação está ativa ou não.\r\n   */\r\n  @State() played = false;\r\n\r\n  /**\r\n   * Observa se o elemento está na viewport.\r\n   */\r\n  observer: IntersectionObserver;\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  ionContent: HTMLIonContentElement;\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  @Element() host: HTMLElement;\r\n\r\n  componentWillLoad() {\r\n    this.ionContent = document.querySelector('ion-content');\r\n    console.log(this.ionContent);\r\n\r\n    if (this.scrollTrigger) {\r\n      console.log('this.scrollTrigger.............');\r\n      this.setupObserver();\r\n    } else {\r\n      // dar a opção de passar um elemento para fazer a animação, tipo o selector do stagger???\r\n      this.executeAnimations();\r\n    }\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.observer.disconnect();\r\n  }\r\n\r\n  setupObserver() {\r\n    this.observer = new IntersectionObserver(\r\n      this.onObserverTriggered.bind(this),\r\n      {\r\n        root: this.ionContent,\r\n        rootMargin: '0% 0% -20% 0%',\r\n        threshold: 0,\r\n      },\r\n    );\r\n\r\n    this.observer.observe(this.host);\r\n  }\r\n\r\n  // refaz a animação sempre que scrolla para baixo...\r\n  previousY = 0;\r\n  previousRatio = 0;\r\n\r\n  onObserverTriggered(entries: IntersectionObserverEntry[]) {\r\n    // // const [entry, ...] = entries;\r\n    if (entries[0].isIntersecting && !this.played) {\r\n      this.executeAnimations();\r\n      this.played = true;\r\n    }\r\n    // entries.forEach((entry) => {\r\n    //   console.log(entry);\r\n    //   if (this.played) return;\r\n\r\n    //   const currentY = entry.boundingClientRect.y;\r\n    //   const currentRatio = entry.intersectionRatio;\r\n    //   const isIntersecting = entry.isIntersecting;\r\n\r\n    //   // Scrolling down/up\r\n    //   if (currentY < this.previousY) {\r\n    //     if (currentRatio > this.previousRatio && isIntersecting) {\r\n    //       console.log('Scrolling down enter');\r\n    //       this.executeAnimations();\r\n    //     } else {\r\n    //       console.log('Scrolling down leave');\r\n    //     }\r\n    //   } else if (currentY > this.previousY && isIntersecting) {\r\n    //     if (currentRatio < this.previousRatio) {\r\n    //       console.log('Scrolling up leave');\r\n    //     } else {\r\n    //       console.log('Scrolling up enter');\r\n    //     }\r\n    //   }\r\n\r\n    //   this.previousY = currentY;\r\n    //   this.previousRatio = currentRatio;\r\n    // });\r\n  }\r\n\r\n  executeAnimations() {\r\n    // switch (this.animation) {\r\n    //   case 'fadein':\r\n    //     fadein(this.host).play();\r\n    //     break;\r\n    //   case 'slideup':\r\n    //     slideup(this.host, this.delay).play();\r\n    //     break;\r\n    //   case 'slideupStagger':\r\n    //     const elements = this.host.querySelectorAll(this.selector);\r\n    //     slideupStagger(elements).forEach((animation) => animation.play());\r\n    //     break;\r\n    // }\r\n  }\r\n\r\n  render() {\r\n    const { animation } = this;\r\n\r\n    return (\r\n      <Host\r\n        class={{\r\n          'tp-animation': true,\r\n          [`tp-animation--${animation}`]: true,\r\n        }}\r\n      >\r\n        <slot />\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n"]}