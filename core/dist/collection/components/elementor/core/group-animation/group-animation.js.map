{"version":3,"file":"group-animation.js","sourceRoot":"","sources":["../../../../../src/components/elementor/core/group-animation/group-animation.tsx"],"names":[],"mappings":"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","sourcesContent":["import { Component, Element, Host, Prop, State, Watch, h } from '@stencil/core';\r\nimport gsap from 'gsap';\r\nimport {\r\n  fadein,\r\n  slideleft,\r\n  slideright,\r\n  slideup,\r\n} from './utils/group-animation.helper';\r\nimport {\r\n  TpGroupAnimationElement,\r\n  TpGroupAnimationType,\r\n} from './utils/group-animation.type';\r\n\r\n@Component({\r\n  tag: 'tp-group-animation',\r\n  styleUrl: 'group-animation.scss',\r\n  scoped: true,\r\n})\r\nexport class TpGroupAnimation {\r\n  @Element() host: HTMLElement;\r\n\r\n  /**\r\n   * Define a animação dos componentes do grupo.\r\n   */\r\n  @Prop({ reflect: true }) animation: TpGroupAnimationType;\r\n\r\n  /**\r\n   * Define se a animação dos componentes será ativada pelo scroll,\r\n   * quando o componente estiver dentro da área de scroll.\r\n   */\r\n  @Prop({ reflect: true }) scrollTrigger = false;\r\n\r\n  /**\r\n   * Define a duração das animações de cada componente do grupo\r\n   * em milissegundos.\r\n   */\r\n  @Prop({ reflect: true }) duration = 500;\r\n\r\n  /**\r\n   * Define o delay do inicio das animações em milissegundos.\r\n   */\r\n  @Prop({ reflect: true }) delay = 0;\r\n\r\n  /**\r\n   * Define o tempo entre o inicio de animações sequenciais\r\n   * em milissegundos.\r\n   */\r\n  @Prop({ reflect: true }) stagger = 0;\r\n\r\n  /**\r\n   * Define a porcentagem da área de scroll que o componente deve\r\n   * atingir para dar inicio a sua animação.\r\n   */\r\n  @Prop({ reflect: true }) intersectionTrigger = 0;\r\n\r\n  /**\r\n   * Define o seletor html/css da área de scroll.\r\n   */\r\n  @Prop({ reflect: true }) scroller: string = 'ion-content';\r\n\r\n  /**\r\n   * O buffer de componenetes que serão animados.\r\n   */\r\n  @State() buffer: TpGroupAnimationElement[] = [];\r\n\r\n  /**\r\n   * Observa se o elemento está na viewport.\r\n   */\r\n  observer: IntersectionObserver;\r\n\r\n  /**\r\n   * O elemento html da área de scroll.\r\n   */\r\n  scrollContainer: HTMLElement;\r\n\r\n  /**\r\n   * A linha do tempo das animações.\r\n   */\r\n  timeline: gsap.core.Timeline = gsap.timeline();\r\n\r\n  /**\r\n   * Define se as animações ja foram iniciadas.\r\n   */\r\n  started = false;\r\n\r\n  /**\r\n   * Event listeners.\r\n   */\r\n  @Watch('buffer')\r\n  onBufferUpdate() {\r\n    this.play();\r\n  }\r\n\r\n  /**\r\n   * Lifecycle hooks.\r\n   */\r\n  componentWillLoad() {\r\n    this.onBeforeComponentLoad();\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.observer.disconnect();\r\n  }\r\n\r\n  /**\r\n   * Métodos internos.\r\n   */\r\n  onBeforeComponentLoad() {\r\n    this.buffer = Array.from(this.host.children).map((element) => ({\r\n      target: element,\r\n      played: false,\r\n      shouldPlay: false,\r\n    }));\r\n\r\n    if (this.scrollTrigger) {\r\n      this.scrollContainer = document.querySelector(this.scroller);\r\n      this.setupObserver();\r\n    } else {\r\n      this.buffer.forEach((element) => (element.shouldPlay = true));\r\n      this.play();\r\n    }\r\n  }\r\n\r\n  setupObserver() {\r\n    this.observer = new IntersectionObserver(\r\n      this.onObserverTriggered.bind(this),\r\n      {\r\n        root: this.scrollContainer,\r\n        rootMargin: `0% 0% -${this.intersectionTrigger}% 0%`,\r\n        threshold: 0,\r\n      },\r\n    );\r\n\r\n    this.buffer.forEach((element) => {\r\n      this.observer.observe(element.target);\r\n    });\r\n  }\r\n\r\n  onObserverTriggered(entries: IntersectionObserverEntry[]) {\r\n    entries.forEach((entry) => {\r\n      if (entry.isIntersecting) {\r\n        const target = entry.target;\r\n        const matchTarget = this.buffer.find((el) => el.target === target);\r\n\r\n        if (matchTarget && !matchTarget.played) {\r\n          matchTarget.shouldPlay = true;\r\n          this.observer.unobserve(matchTarget.target);\r\n        }\r\n      }\r\n    });\r\n\r\n    this.buffer = [...this.buffer];\r\n  }\r\n\r\n  play() {\r\n    const currentBuffer = [\r\n      ...this.buffer.filter((element) => !element.played && element.shouldPlay),\r\n    ];\r\n\r\n    let animation: any;\r\n    switch (this.animation) {\r\n      case 'fadein':\r\n        animation = fadein;\r\n        break;\r\n\r\n      case 'slideup':\r\n        animation = slideup;\r\n        break;\r\n\r\n      case 'slideleft':\r\n        animation = slideleft;\r\n        break;\r\n\r\n      case 'slideright':\r\n        animation = slideright;\r\n        break;\r\n\r\n      default:\r\n        animation = fadein;\r\n    }\r\n\r\n    const activeElements = currentBuffer.map((element) => element.target);\r\n    const delay = this.started ? 0 : this.delay;\r\n    this.timeline.add(\r\n      animation(activeElements, delay, this.stagger, this.duration),\r\n    );\r\n    currentBuffer.forEach((element) => (element.played = true));\r\n\r\n    if (!this.started) this.started = true;\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <Host\r\n        class={{\r\n          'tp-animation': true,\r\n          [`tp-animation--${this.animation}`]: true,\r\n        }}\r\n      >\r\n        <slot />\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n"]}