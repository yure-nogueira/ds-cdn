{"version":3,"file":"recognizers.js","sourceRoot":"","sources":["../../../../../../src/components/core/calendar/utils/gesture/recognizers.ts"],"names":[],"mappings":"AAQA,MAAM,CAAC,MAAM,mBAAmB,GAAG,CAAC,SAAiB,EAAE,MAAc,EAAE,QAAgB,EAAiB,EAAE;IACxG,MAAM,OAAO,GAAG,QAAQ,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,GAAG,CAAC,CAAC;IAC3C,MAAM,MAAM,GAAG,SAAS,KAAK,GAAG,CAAC;IACjC,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IACpC,MAAM,SAAS,GAAG,MAAM,GAAG,MAAM,CAAC;IAElC,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,IAAI,MAAM,GAAG,CAAC,CAAC;IAEf,IAAI,KAAK,GAAG,KAAK,CAAC;IAClB,IAAI,KAAK,GAAG,CAAC,CAAC;IAEd,OAAO;QACL,KAAK,CAAC,CAAS,EAAE,CAAS;YACxB,MAAM,GAAG,CAAC,CAAC;YACX,MAAM,GAAG,CAAC,CAAC;YACX,KAAK,GAAG,CAAC,CAAC;YACV,KAAK,GAAG,IAAI,CAAC;QACf,CAAC;QAED,MAAM,CAAC,CAAS,EAAE,CAAS;YACzB,IAAI,CAAC,KAAK,EAAE,CAAC;gBACX,OAAO,KAAK,CAAC;YACf,CAAC;YAED,MAAM,MAAM,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC;YAC5B,MAAM,MAAM,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC;YAC5B,MAAM,QAAQ,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,CAAC;YAEnD,IAAI,QAAQ,GAAG,SAAS,EAAE,CAAC;gBACzB,OAAO,KAAK,CAAC;YACf,CAAC;YACD,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACvC,MAAM,MAAM,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,UAAU,CAAC;YAEvD,IAAI,MAAM,GAAG,SAAS,EAAE,CAAC;gBACvB,KAAK,GAAG,CAAC,CAAC;YAEZ,CAAC;iBAAM,IAAI,MAAM,GAAG,CAAC,SAAS,EAAE,CAAC;gBAC/B,KAAK,GAAG,CAAC,CAAC,CAAC;YAEb,CAAC;iBAAM,CAAC;gBACN,KAAK,GAAG,CAAC,CAAC;YACZ,CAAC;YAED,KAAK,GAAG,KAAK,CAAC;YACd,OAAO,IAAI,CAAC;QACd,CAAC;QAED,SAAS;YACP,OAAO,KAAK,KAAK,CAAC,CAAC;QACrB,CAAC;QAED,YAAY;YACV,OAAO,KAAK,CAAC;QACf,CAAC;KACF,CAAC;AACJ,CAAC,CAAC","sourcesContent":["\r\nexport interface PanRecognizer {\r\n  start(x: number, y: number): void;\r\n  detect(x: number, y: number): boolean;\r\n  isGesture(): boolean;\r\n  getDirection(): number;\r\n}\r\n\r\nexport const createPanRecognizer = (direction: string, thresh: number, maxAngle: number): PanRecognizer => {\r\n  const radians = maxAngle * (Math.PI / 180);\r\n  const isDirX = direction === 'x';\r\n  const maxCosine = Math.cos(radians);\r\n  const threshold = thresh * thresh;\r\n\r\n  let startX = 0;\r\n  let startY = 0;\r\n\r\n  let dirty = false;\r\n  let isPan = 0;\r\n\r\n  return {\r\n    start(x: number, y: number) {\r\n      startX = x;\r\n      startY = y;\r\n      isPan = 0;\r\n      dirty = true;\r\n    },\r\n\r\n    detect(x: number, y: number): boolean {\r\n      if (!dirty) {\r\n        return false;\r\n      }\r\n\r\n      const deltaX = (x - startX);\r\n      const deltaY = (y - startY);\r\n      const distance = deltaX * deltaX + deltaY * deltaY;\r\n\r\n      if (distance < threshold) {\r\n        return false;\r\n      }\r\n      const hypotenuse = Math.sqrt(distance);\r\n      const cosine = (isDirX ? deltaX : deltaY) / hypotenuse;\r\n\r\n      if (cosine > maxCosine) {\r\n        isPan = 1;\r\n\r\n      } else if (cosine < -maxCosine) {\r\n        isPan = -1;\r\n\r\n      } else {\r\n        isPan = 0;\r\n      }\r\n\r\n      dirty = false;\r\n      return true;\r\n    },\r\n\r\n    isGesture(): boolean {\r\n      return isPan !== 0;\r\n    },\r\n\r\n    getDirection(): number {\r\n      return isPan;\r\n    }\r\n  };\r\n};\r\n"]}