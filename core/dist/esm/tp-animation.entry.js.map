{"file":"tp-animation.entry.js","mappings":";;AAAA,MAAM,YAAY,GAAG,4DAA4D,CAAC;AAClF,0BAAe,YAAY;;MCOd,WAAW;;;;QAyEtB,cAAS,GAAG,CAAC,CAAC;QACd,kBAAa,GAAG,CAAC,CAAC;6BAtEuB,KAAK;;yBAW5C,QAAQ;qBAK+B,CAAC;sBAKxB,KAAK;;IAiBvB,iBAAiB;QACf,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;QACxD,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAE7B,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,OAAO,CAAC,GAAG,CAAC,iCAAiC,CAAC,CAAC;YAC/C,IAAI,CAAC,aAAa,EAAE,CAAC;SACtB;aAAM;;YAEL,IAAI,CAAC,iBAAiB,EAAE,CAAC;SAC1B;KACF;IAED,oBAAoB;QAClB,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,CAAC;KAC5B;IAED,aAAa;QACX,IAAI,CAAC,QAAQ,GAAG,IAAI,oBAAoB,CACtC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,EACnC;YACE,IAAI,EAAE,IAAI,CAAC,UAAU;YACrB,UAAU,EAAE,eAAe;YAC3B,SAAS,EAAE,CAAC;SACb,CACF,CAAC;QAEF,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KAClC;IAMD,mBAAmB,CAAC,OAAoC;;QAEtD,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,cAAc,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YAC7C,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACzB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;SACpB;;;;;;;;;;;;;;;;;;;;;;;;;KA4BF;IAED,iBAAiB;;;;;;;;;;;;;KAahB;IAED,MAAM;QACJ,MAAM,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC;QAE3B,QACE,EAAC,IAAI,qDACH,KAAK,EAAE;gBACL,cAAc,EAAE,IAAI;gBACpB,CAAC,iBAAiB,SAAS,EAAE,GAAG,IAAI;aACrC,IAED,8DAAQ,CACH,EACP;KACH;;;;;;;","names":[],"sources":["src/components/elementor/core/animation/animation.scss?tag=tp-animation&encapsulation=scoped","src/components/elementor/core/animation/animation.tsx"],"sourcesContent":["@import '../../../../styles/templarios.abstracts';\r\n\r\n:host {\r\n  // display: block;\r\n  display: inline-block;\r\n  position: relative;\r\n  // opacity: 0;\r\n}\r\n","import { Component, Element, Host, Prop, State, h } from '@stencil/core';\r\n// import { fadein, slideup, slideupStagger } from './utils/animations.helper';\r\n\r\n@Component({\r\n  tag: 'tp-animation',\r\n  styleUrl: 'animation.scss',\r\n  scoped: true,\r\n})\r\nexport class TpAnimation {\r\n  /**\r\n   * todo.\r\n   */\r\n  @Prop({ reflect: true }) scrollTrigger = false;\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  @Prop({ reflect: true }) selector: string;\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  @Prop({ reflect: true }) animation: 'fadein' | 'slideup' | 'slideupStagger' =\r\n    'fadein';\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  @Prop({ reflect: true }) delay: number = 0;\r\n\r\n  /**\r\n   * Define se a animação está ativa ou não.\r\n   */\r\n  @State() played = false;\r\n\r\n  /**\r\n   * Observa se o elemento está na viewport.\r\n   */\r\n  observer: IntersectionObserver;\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  ionContent: HTMLIonContentElement;\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  @Element() host: HTMLElement;\r\n\r\n  componentWillLoad() {\r\n    this.ionContent = document.querySelector('ion-content');\r\n    console.log(this.ionContent);\r\n\r\n    if (this.scrollTrigger) {\r\n      console.log('this.scrollTrigger.............');\r\n      this.setupObserver();\r\n    } else {\r\n      // dar a opção de passar um elemento para fazer a animação, tipo o selector do stagger???\r\n      this.executeAnimations();\r\n    }\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.observer.disconnect();\r\n  }\r\n\r\n  setupObserver() {\r\n    this.observer = new IntersectionObserver(\r\n      this.onObserverTriggered.bind(this),\r\n      {\r\n        root: this.ionContent,\r\n        rootMargin: '0% 0% -20% 0%',\r\n        threshold: 0,\r\n      },\r\n    );\r\n\r\n    this.observer.observe(this.host);\r\n  }\r\n\r\n  // refaz a animação sempre que scrolla para baixo...\r\n  previousY = 0;\r\n  previousRatio = 0;\r\n\r\n  onObserverTriggered(entries: IntersectionObserverEntry[]) {\r\n    // // const [entry, ...] = entries;\r\n    if (entries[0].isIntersecting && !this.played) {\r\n      this.executeAnimations();\r\n      this.played = true;\r\n    }\r\n    // entries.forEach((entry) => {\r\n    //   console.log(entry);\r\n    //   if (this.played) return;\r\n\r\n    //   const currentY = entry.boundingClientRect.y;\r\n    //   const currentRatio = entry.intersectionRatio;\r\n    //   const isIntersecting = entry.isIntersecting;\r\n\r\n    //   // Scrolling down/up\r\n    //   if (currentY < this.previousY) {\r\n    //     if (currentRatio > this.previousRatio && isIntersecting) {\r\n    //       console.log('Scrolling down enter');\r\n    //       this.executeAnimations();\r\n    //     } else {\r\n    //       console.log('Scrolling down leave');\r\n    //     }\r\n    //   } else if (currentY > this.previousY && isIntersecting) {\r\n    //     if (currentRatio < this.previousRatio) {\r\n    //       console.log('Scrolling up leave');\r\n    //     } else {\r\n    //       console.log('Scrolling up enter');\r\n    //     }\r\n    //   }\r\n\r\n    //   this.previousY = currentY;\r\n    //   this.previousRatio = currentRatio;\r\n    // });\r\n  }\r\n\r\n  executeAnimations() {\r\n    // switch (this.animation) {\r\n    //   case 'fadein':\r\n    //     fadein(this.host).play();\r\n    //     break;\r\n    //   case 'slideup':\r\n    //     slideup(this.host, this.delay).play();\r\n    //     break;\r\n    //   case 'slideupStagger':\r\n    //     const elements = this.host.querySelectorAll(this.selector);\r\n    //     slideupStagger(elements).forEach((animation) => animation.play());\r\n    //     break;\r\n    // }\r\n  }\r\n\r\n  render() {\r\n    const { animation } = this;\r\n\r\n    return (\r\n      <Host\r\n        class={{\r\n          'tp-animation': true,\r\n          [`tp-animation--${animation}`]: true,\r\n        }}\r\n      >\r\n        <slot />\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n"],"version":3}