{"version":3,"names":["animationCss","TpAnimationStyle0","TpAnimation","this","previousY","previousRatio","componentWillLoad","ionContent","document","querySelector","console","log","scrollTrigger","setupObserver","executeAnimations","disconnectedCallback","observer","disconnect","IntersectionObserver","onObserverTriggered","bind","root","rootMargin","threshold","observe","host","entries","isIntersecting","played","render","animation","h","Host","key","class"],"sources":["src/components/elementor/core/animation/animation.scss?tag=tp-animation&encapsulation=scoped","src/components/elementor/core/animation/animation.tsx"],"sourcesContent":["@import '../../../../styles/templarios.abstracts';\r\n\r\n:host {\r\n  // display: block;\r\n  display: inline-block;\r\n  position: relative;\r\n  // opacity: 0;\r\n}\r\n","import { Component, Element, Host, Prop, State, h } from '@stencil/core';\r\n// import { fadein, slideup, slideupStagger } from './utils/animations.helper';\r\n\r\n@Component({\r\n  tag: 'tp-animation',\r\n  styleUrl: 'animation.scss',\r\n  scoped: true,\r\n})\r\nexport class TpAnimation {\r\n  /**\r\n   * todo.\r\n   */\r\n  @Prop({ reflect: true }) scrollTrigger = false;\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  @Prop({ reflect: true }) selector: string;\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  @Prop({ reflect: true }) animation: 'fadein' | 'slideup' | 'slideupStagger' =\r\n    'fadein';\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  @Prop({ reflect: true }) delay: number = 0;\r\n\r\n  /**\r\n   * Define se a animação está ativa ou não.\r\n   */\r\n  @State() played = false;\r\n\r\n  /**\r\n   * Observa se o elemento está na viewport.\r\n   */\r\n  observer: IntersectionObserver;\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  ionContent: HTMLIonContentElement;\r\n\r\n  /**\r\n   * todo.\r\n   */\r\n  @Element() host: HTMLElement;\r\n\r\n  componentWillLoad() {\r\n    this.ionContent = document.querySelector('ion-content');\r\n    console.log(this.ionContent);\r\n\r\n    if (this.scrollTrigger) {\r\n      console.log('this.scrollTrigger.............');\r\n      this.setupObserver();\r\n    } else {\r\n      // dar a opção de passar um elemento para fazer a animação, tipo o selector do stagger???\r\n      this.executeAnimations();\r\n    }\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.observer.disconnect();\r\n  }\r\n\r\n  setupObserver() {\r\n    this.observer = new IntersectionObserver(\r\n      this.onObserverTriggered.bind(this),\r\n      {\r\n        root: this.ionContent,\r\n        rootMargin: '0% 0% -20% 0%',\r\n        threshold: 0,\r\n      },\r\n    );\r\n\r\n    this.observer.observe(this.host);\r\n  }\r\n\r\n  // refaz a animação sempre que scrolla para baixo...\r\n  previousY = 0;\r\n  previousRatio = 0;\r\n\r\n  onObserverTriggered(entries: IntersectionObserverEntry[]) {\r\n    // // const [entry, ...] = entries;\r\n    if (entries[0].isIntersecting && !this.played) {\r\n      this.executeAnimations();\r\n      this.played = true;\r\n    }\r\n    // entries.forEach((entry) => {\r\n    //   console.log(entry);\r\n    //   if (this.played) return;\r\n\r\n    //   const currentY = entry.boundingClientRect.y;\r\n    //   const currentRatio = entry.intersectionRatio;\r\n    //   const isIntersecting = entry.isIntersecting;\r\n\r\n    //   // Scrolling down/up\r\n    //   if (currentY < this.previousY) {\r\n    //     if (currentRatio > this.previousRatio && isIntersecting) {\r\n    //       console.log('Scrolling down enter');\r\n    //       this.executeAnimations();\r\n    //     } else {\r\n    //       console.log('Scrolling down leave');\r\n    //     }\r\n    //   } else if (currentY > this.previousY && isIntersecting) {\r\n    //     if (currentRatio < this.previousRatio) {\r\n    //       console.log('Scrolling up leave');\r\n    //     } else {\r\n    //       console.log('Scrolling up enter');\r\n    //     }\r\n    //   }\r\n\r\n    //   this.previousY = currentY;\r\n    //   this.previousRatio = currentRatio;\r\n    // });\r\n  }\r\n\r\n  executeAnimations() {\r\n    // switch (this.animation) {\r\n    //   case 'fadein':\r\n    //     fadein(this.host).play();\r\n    //     break;\r\n    //   case 'slideup':\r\n    //     slideup(this.host, this.delay).play();\r\n    //     break;\r\n    //   case 'slideupStagger':\r\n    //     const elements = this.host.querySelectorAll(this.selector);\r\n    //     slideupStagger(elements).forEach((animation) => animation.play());\r\n    //     break;\r\n    // }\r\n  }\r\n\r\n  render() {\r\n    const { animation } = this;\r\n\r\n    return (\r\n      <Host\r\n        class={{\r\n          'tp-animation': true,\r\n          [`tp-animation--${animation}`]: true,\r\n        }}\r\n      >\r\n        <slot />\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n"],"mappings":"yDAAA,MAAMA,EAAe,6DACrB,MAAAC,EAAeD,E,MCOFE,EAAW,M,yBAyEtBC,KAAAC,UAAY,EACZD,KAAAE,cAAgB,E,mBAtEyB,M,uCAWvC,S,WAKuC,E,YAKvB,K,CAiBlB,iBAAAC,GACEH,KAAKI,WAAaC,SAASC,cAAc,eACzCC,QAAQC,IAAIR,KAAKI,YAEjB,GAAIJ,KAAKS,cAAe,CACtBF,QAAQC,IAAI,mCACZR,KAAKU,e,KACA,CAELV,KAAKW,mB,EAIT,oBAAAC,GACEZ,KAAKa,SAASC,Y,CAGhB,aAAAJ,GACEV,KAAKa,SAAW,IAAIE,qBAClBf,KAAKgB,oBAAoBC,KAAKjB,MAC9B,CACEkB,KAAMlB,KAAKI,WACXe,WAAY,gBACZC,UAAW,IAIfpB,KAAKa,SAASQ,QAAQrB,KAAKsB,K,CAO7B,mBAAAN,CAAoBO,GAElB,GAAIA,EAAQ,GAAGC,iBAAmBxB,KAAKyB,OAAQ,CAC7CzB,KAAKW,oBACLX,KAAKyB,OAAS,I,EA+BlB,iBAAAd,G,CAeA,MAAAe,GACE,MAAMC,UAAEA,GAAc3B,KAEtB,OACE4B,EAACC,EAAI,CAAAC,IAAA,2CACHC,MAAO,CACL,eAAgB,KAChB,CAAC,iBAAiBJ,KAAc,OAGlCC,EAAA,QAAAE,IAAA,6C"}